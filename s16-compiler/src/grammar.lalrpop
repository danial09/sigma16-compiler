// compiler/src/grammar.lalrpop

use crate::ir::ast::*;
use crate::frontend::lexer::{Token, LexicalError};
use crate::ir::AstNodeKind;
use std::cell::RefCell;

// Ignore 'Missing lifetime specifier' errors on below line if using the RustRover "lalrpop" plugin.
grammar(id_gen: &RefCell<AstNodeIdGenerator>, spans: &RefCell<SpanCollector>);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "If"      => Token::If,
        "Else"    => Token::Else,
        "While"   => Token::While,
        "For"     => Token::For,
        "From"    => Token::From,
        "To"      => Token::To,
        "Fn"      => Token::Fn,
        "Return"  => Token::Return,
        "Array"   => Token::Array,
        "Global"  => Token::Global,
        "And"     => Token::And,
        "Or"      => Token::Or,
        "Not"     => Token::Not,

        "Ident"   => Token::Ident(<String>),
        "Number"  => Token::Number(<i64>),

        "Assign"  => Token::Assign,
        "Plus"    => Token::Plus,
        "Minus"   => Token::Minus,
        "Mul"     => Token::Mul,
        "Div"     => Token::Div,
        "Mod"     => Token::Mod,

        "Eq"      => Token::Eq,     // '=='
        "Neq"     => Token::Neq,    // '!='
        "Lt"      => Token::Lt,     // '<'
        "Gt"      => Token::Gt,     // '>'
        "Ge"      => Token::Ge,     // '>='
        "Le"      => Token::Le,     // '<='

        "LBrace"  => Token::LBrace,
        "RBrace"  => Token::RBrace,
        "LParen"  => Token::LParen,
        "RParen"  => Token::RParen,
        "LBracket" => Token::LBracket,
        "RBracket" => Token::RBracket,
        "Comma"    => Token::Comma,
        "Amp"      => Token::Amp,
        "Pipe"     => Token::Pipe,
        "Caret"    => Token::Caret,
        "Tilde"    => Token::Tilde,
        "Semicolon" => Token::Semicolon,
        "String"   => Token::String(<String>),
    }
}

// ========== Entry Point ==========

pub Program: Program =
    <statements:Stmt*> => Program { statements };

// ========== Statements ==========

Stmt: Stmt = {
    IfStmt,
    WhileStmt,
    ForStmt,
    ReturnStmt,
    FunctionDef,
    ArrayDeclStmt,
    GlobalAssignStmt,
    IdentBasedStmt,
    DereferencedAssignStmt,
};

IdentBasedStmt: Stmt = {
    <l:@L> <name:"Ident"> "Assign" <value:"String"> "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Stmt::StringDecl { id, name: name.into(), value }
    },
    <l:@L> <v:"Ident"> "Assign" <value:ExprOr> "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Assign);
        Stmt::Assign { id, target: LValue::Var(v.into()), value }
    },
    <l:@L> <v:"Ident"> "LBracket" <idx:ExprOr> "RBracket" "Assign" <value:ExprOr> "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Assign);
        Stmt::Assign { id, target: LValue::Index { base: v.into(), index: idx }, value }
    },
    <l:@L> <name:"Ident"> "LParen" <args:ArgList?> "RParen" "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Stmt::ExprStmt { id, expr: Expr::Call { id, name: name.into(), args: args.unwrap_or_default() } }
    },
};

DereferencedAssignStmt: Stmt = 
    <l:@L> "Mul" <e:ExprUnary> "Assign" <value:ExprOr> "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Assign);
        Stmt::Assign { id, target: LValue::Deref(Box::new(e)), value }
    };

ArrayDeclStmt: Stmt = {
    <l:@L> "Array" <name:"Ident"> "LBracket" <n:"Number"> "RBracket" "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Stmt::ArrayDecl { id, name: name.into(), size: n as usize, initial_values: None }
    },

    <l:@L> "Array" <name:"Ident"> "LBracket" <n:"Number"> "RBracket" "Assign" "LBracket" <vals:NumberList> "RBracket" "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Stmt::ArrayDecl { id, name: name.into(), size: n as usize, initial_values: Some(vals) }
    },
};

GlobalAssignStmt: Stmt =
    <l:@L> "Global" <name:"Ident"> "Assign" <value:ExprOr> "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Assign);
        Stmt::GlobalAssign { id, name: name.into(), value }
    };

NumberList: Vec<i64> =
    <first:"Number"> <rest:("Comma" <"Number">)*> => {
        let mut v = Vec::new();
        v.push(first);
        for id in rest { v.push(id); }
        v
    };

FunctionDef: Stmt =
    <l:@L> "Fn" <name:"Ident"> "LParen" <params:ParamList?> "RParen" <body:Block> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Stmt::Function { id, name: name.into(), params: params.unwrap_or_default(), body }
    };

ParamList: Vec<String> =
    <first:"Ident"> <rest:("Comma" <"Ident">)*> => {
        let mut v = Vec::new();
        v.push(first.into());
        for id in rest { v.push(id); }
        v
    };

IfStmt: Stmt = {
    <l:@L> "If" <condition:ExprOr> <then_branch:Block> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::If);
        Stmt::If { id, condition, then_branch, else_branch: None }
    },

    <l:@L> "If" <condition:ExprOr> <then_branch:Block> "Else" <else_branch:Block> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::If);
        Stmt::If { id, condition, then_branch, else_branch: Some(else_branch) }
    },
};

WhileStmt: Stmt =
    <l:@L> "While" <condition:ExprOr> <body:Block> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::While);
        Stmt::While { id, condition, body }
    };

ForStmt: Stmt =
    <l:@L> "For" <var:"Ident"> "From" <from:ExprOr> "To" <to:ExprOr> <body:Block> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::For);
        Stmt::For { id, var: var.into(), from, to, body }
    };

Block: Vec<Stmt> =
    "LBrace" <Stmt*> "RBrace";

ReturnStmt: Stmt = {
    <l:@L> "Return" <value:ExprOr> "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Unary);
        Stmt::Return { id, value: Some(value) }
    },
    <l:@L> "Return" "Semicolon" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Unary);
        Stmt::Return { id, value: None }
    },
};

// Standalone function call as statement (ignored return)
// Handled in IdentBasedStmt

// ========== Expressions (Precedence Climbing) ==========

// Lowest precedence: logical OR
ExprOr: Expr = {
    <l:@L> <left:ExprOr> "Or" <right:ExprAnd> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op: BinOp::Or, left: Box::new(left), right: Box::new(right) }
    },
    ExprAnd,
};

// Logical AND (higher precedence than OR)
ExprAnd: Expr = {
    <l:@L> <left:ExprAnd> "And" <right:ExprBitOr> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op: BinOp::And, left: Box::new(left), right: Box::new(right) }
    },
    ExprBitOr,
};

// Bitwise OR (higher precedence than logical AND)
ExprBitOr: Expr = {
    <l:@L> <left:ExprBitOr> "Pipe" <right:ExprBitXor> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op: BinOp::BitOr, left: Box::new(left), right: Box::new(right) }
    },
    ExprBitXor,
};

// Bitwise XOR (higher precedence than bitwise OR)
ExprBitXor: Expr = {
    <l:@L> <left:ExprBitXor> "Caret" <right:ExprBitAnd> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op: BinOp::BitXor, left: Box::new(left), right: Box::new(right) }
    },
    ExprBitAnd,
};

// Bitwise AND (higher precedence than bitwise XOR)
ExprBitAnd: Expr = {
    <l:@L> <left:ExprBitAnd> "Amp" <right:ExprCmp> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op: BinOp::BitAnd, left: Box::new(left), right: Box::new(right) }
    },
    ExprCmp,
};

// Comparison operators (non-associative, but we allow chaining here)
ExprCmp: Expr = {
    <l:@L> <left:ExprAdd> <op:CmpOp> <right:ExprAdd> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op, left: Box::new(left), right: Box::new(right) }
    },
    ExprAdd,
};

CmpOp: BinOp = {
    "Eq"  => BinOp::Eq,
    "Neq" => BinOp::Neq,
    "Lt"  => BinOp::Lt,
    "Gt"  => BinOp::Gt,
    "Le"  => BinOp::Le,
    "Ge"  => BinOp::Ge,
};

// Addition and subtraction (left-associative)
ExprAdd: Expr = {
    <l:@L> <left:ExprAdd> <op:AddOp> <right:ExprMul> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op, left: Box::new(left), right: Box::new(right) }
    },
    ExprMul,
};

AddOp: BinOp = {
    "Plus"  => BinOp::Add,
    "Minus" => BinOp::Sub,
};

// Multiplication and division (left-associative)
ExprMul: Expr = {
    <l:@L> <left:ExprMul> <op:MulOp> <right:ExprUnary> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Binary { id, op, left: Box::new(left), right: Box::new(right) }
    },
    ExprUnary,
};

MulOp: BinOp = {
    "Mul" => BinOp::Mul,
    "Div" => BinOp::Div,
    "Mod" => BinOp::Mod,
};

// Unary operators (higher precedence than binary operators)
ExprUnary: Expr = {
    <l:@L> "Not" <operand:ExprUnary> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Unary);
        Expr::Unary { id, op: UnOp::Not, operand: Box::new(operand) }
    },
    <l:@L> "Minus" <operand:ExprUnary> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Unary);
        Expr::Unary { id, op: UnOp::Neg, operand: Box::new(operand) }
    },
    <l:@L> "Tilde" <operand:ExprUnary> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Unary);
        Expr::Unary { id, op: UnOp::BitNot, operand: Box::new(operand) }
    },
    // Address-of a variable
    <l:@L> "Amp" <v:"Ident"> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Unary);
        Expr::AddrOf(id, v.into())
    },
    // Dereference
    <l:@L> "Mul" <operand:ExprUnary> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Unary);
        Expr::Deref(id, Box::new(operand))
    },
    ExprPrimary,
};

// Primary expressions
ExprPrimary: Expr = {
    // Indexing a[i] must appear before bare Ident to avoid ambiguity
    <l:@L> <v:"Ident"> "LBracket" <idx:ExprOr> "RBracket" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Binary);
        Expr::Index { id, base: v.into(), index: Box::new(idx) }
    },
    // Function call: name(args)
    <l:@L> <name:"Ident"> "LParen" <args:ArgList?> "RParen" <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Expr::Call { id, name: name.into(), args: args.unwrap_or_default() }
    },
    <l:@L> <n:"Number"> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Number);
        Expr::Number(id, n.into())
    },
    // global x â€” read a global variable from within a function
    <l:@L> "Global" <v:"Ident"> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Expr::GlobalVar(id, v.into())
    },
    <l:@L> <v:"Ident"> <r:@R> => {
        let id = id_gen.borrow_mut().next();
        spans.borrow_mut().add(id, l, r, AstNodeKind::Variable);
        Expr::Variable(id, v.into())
    },
    "LParen" <ExprOr> "RParen",
};

ArgList: Vec<Expr> =
    <first:ExprOr> <rest:("Comma" <ExprOr>)*> => {
        let mut v = Vec::new();
        v.push(first);
        for e in rest { v.push(e); }
        v
    };

// LValue for assignment target
LValue: LValue = {
    <v:"Ident"> => LValue::Var(v.into()),
    // *p
    "Mul" <e:ExprUnary> => LValue::Deref(Box::new(e)),
    // a[i]
    <v:"Ident"> "LBracket" <idx:ExprOr> "RBracket" => LValue::Index { base: v.into(), index: idx },
};
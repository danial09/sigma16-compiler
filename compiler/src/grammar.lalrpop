
// compiler/src/grammar.lalrpop

use crate::ast::*;
use crate::lexer::{Token, LexicalError};
use crate::ir::AstNodeId;
use std::cell::RefCell;

grammar(id_gen: &RefCell<AstNodeIdGenerator>);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "If"      => Token::If,
        "Else"    => Token::Else,
        "While"   => Token::While,
        "For"     => Token::For,
        "From"    => Token::From,
        "To"      => Token::To,
        "And"     => Token::And,
        "Or"      => Token::Or,
        "Not"     => Token::Not,

        "Ident"   => Token::Ident(<String>),
        "Number"  => Token::Number(<i64>),

        "Assign"  => Token::Assign,
        "Plus"    => Token::Plus,
        "Minus"   => Token::Minus,
        "Mul"     => Token::Mul,
        "Div"     => Token::Div,

        "Eq"      => Token::Eq,     // '=='
        "Neq"     => Token::Neq,    // '!='
        "Lt"      => Token::Lt,     // '<'
        "Gt"      => Token::Gt,     // '>'

        "LBrace"  => Token::LBrace,
        "RBrace"  => Token::RBrace,
        "LParen"  => Token::LParen,
        "RParen"  => Token::RParen,
    }
}

// ========== Entry Point ==========

pub Program: Program =
    <statements:Stmt*> => Program { statements };

// ========== Statements ==========

Stmt: Stmt = {
    AssignStmt,
    IfStmt,
    WhileStmt,
    ForStmt,
};

AssignStmt: Stmt =
    <name:"Ident"> "Assign" <value:ExprOr> => {
        let id = id_gen.borrow_mut().next();
        Stmt::Assign { 
            id,
            name: name.into(), 
            value 
        }
    };

IfStmt: Stmt = {
    "If" <condition:ExprOr> <then_branch:Block> => {
        let id = id_gen.borrow_mut().next();
        Stmt::If { id, condition, then_branch, else_branch: None }
    },

    "If" <condition:ExprOr> <then_branch:Block> "Else" <else_branch:Block> => {
        let id = id_gen.borrow_mut().next();
        Stmt::If { id, condition, then_branch, else_branch: Some(else_branch) }
    },
};

WhileStmt: Stmt =
    "While" <condition:ExprOr> <body:Block> => {
        let id = id_gen.borrow_mut().next();
        Stmt::While { id, condition, body }
    };

ForStmt: Stmt =
    "For" <var:"Ident"> "From" <from:ExprOr> "To" <to:ExprOr> <body:Block> => {
        let id = id_gen.borrow_mut().next();
        Stmt::For { id, var: var.into(), from, to, body }
    };

Block: Vec<Stmt> =
    "LBrace" <Stmt*> "RBrace";

// ========== Expressions (Precedence Climbing) ==========

// Lowest precedence: logical OR
ExprOr: Expr = {
    <left:ExprOr> "Or" <right:ExprAnd> => {
        let id = id_gen.borrow_mut().next();
        Expr::Binary { id, op: BinOp::Or, left: Box::new(left), right: Box::new(right) }
    },
    ExprAnd,
};

// Logical AND (higher precedence than OR)
ExprAnd: Expr = {
    <left:ExprAnd> "And" <right:ExprCmp> => {
        let id = id_gen.borrow_mut().next();
        Expr::Binary { id, op: BinOp::And, left: Box::new(left), right: Box::new(right) }
    },
    ExprCmp,
};

// Comparison operators (non-associative, but we allow chaining here)
ExprCmp: Expr = {
    <left:ExprAdd> <op:CmpOp> <right:ExprAdd> => {
        let id = id_gen.borrow_mut().next();
        Expr::Binary { id, op, left: Box::new(left), right: Box::new(right) }
    },
    ExprAdd,
};

CmpOp: BinOp = {
    "Eq"  => BinOp::Eq,
    "Neq" => BinOp::Neq,
    "Lt"  => BinOp::Lt,
    "Gt"  => BinOp::Gt,
};

// Addition and subtraction (left-associative)
ExprAdd: Expr = {
    <left:ExprAdd> <op:AddOp> <right:ExprMul> => {
        let id = id_gen.borrow_mut().next();
        Expr::Binary { id, op, left: Box::new(left), right: Box::new(right) }
    },
    ExprMul,
};

AddOp: BinOp = {
    "Plus"  => BinOp::Add,
    "Minus" => BinOp::Sub,
};

// Multiplication and division (left-associative)
ExprMul: Expr = {
    <left:ExprMul> <op:MulOp> <right:ExprUnary> => {
        let id = id_gen.borrow_mut().next();
        Expr::Binary { id, op, left: Box::new(left), right: Box::new(right) }
    },
    ExprUnary,
};

MulOp: BinOp = {
    "Mul" => BinOp::Mul,
    "Div" => BinOp::Div,
};

// Unary operators (higher precedence than binary operators)
ExprUnary: Expr = {
    "Not" <operand:ExprUnary> => {
        let id = id_gen.borrow_mut().next();
        Expr::Unary { id, op: UnOp::Not, operand: Box::new(operand) }
    },
    ExprPrimary,
};

// Highest precedence: primary expressions
ExprPrimary: Expr = {
    <n:"Number"> => {
        let id = id_gen.borrow_mut().next();
        Expr::Number(id, n.into())
    },
    <v:"Ident"> => {
        let id = id_gen.borrow_mut().next();
        Expr::Variable(id, v.into())
    },
    "LParen" <ExprOr> "RParen",
};